---
title: Introduction to distributed tracing
contentType: page
template: basicDoc
topics:
  - Understand dependencies
  - Distributed tracing
  - Get started
japaneseVersion: >-
  https://docs.newrelic.co.jp/docs/understand-dependencies/distributed-tracing/get-started/introduction-distributed-tracing
---

Distributed tracing extends APM transaction tracing. Transaction tracing is effective for analyzing activity in one application. With distributed tracing, you can see the entire journey your requests take as they travel through distributed systems.

## Quick start

To get started right away:

* [Learn:](/docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works#sampling) Check out the different types of distributed tracing with New Relic.
* [Enable:](/docs/understand-dependencies/distributed-tracing/enable-configure/overview-enable-distributed-tracing) See how to set up distributed tracing.
* [Use:](/docs/apm/distributed-tracing/ui-data/understand-use-distributed-tracing-data) View your traces in the UI after you enable distributed tracing.

## Why distributed tracing matters

While APM transaction tracing is helpful for analyzing calls in a single application, distributed tracing broadens your view by showing the path a request takes across multiple applications and services–from start to finish. With this wider view, you can quickly troubleshoot performance bottlenecks and errors.

As requests travel between services, each segment is recorded as a span, which represents time spent in services or resources of those services. All the spans of a request are combined into a single distributed trace to give you a picture of an entire request.

Once your traces are captured in New Relic, here’s what you can do:

* [See the user experience:](/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing) If you enable distributed tracing for Browser, you can tie that client/user experience to the backend code. You can understand which users are affected by a backend error or code change.
* [Track your lambda functions:](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda) If you enable distributed tracing for your lambda functions, serverless code will be connected to all of your other code as it executes.
* [Detect anomalous spans:](/docs/apm/distributed-tracing/ui-data/understand-use-distributed-tracing-data#anomalous-spans) Spans that are slow in comparison to typical behavior are marked as anomalous, with charts comparing them to typical performance.
* [See your errors and logs:](/docs/understand-dependencies/distributed-tracing/ui-data/understand-use-distributed-tracing-ui#view-your-logs) Frontend and backend errors appear right in the context of your traces. Everything you need to troubleshoot is in one place.
* [Filter results:](/docs/apm/distributed-tracing/ui-data/understand-use-distributed-tracing-data) You can filter charts using many data points, so you can analyze trace data in different ways.
* [Customize queries and dashboards:](/docs/insights/use-insights-ui/manage-dashboards/create-edit-copy-insights-dashboards) You can create custom queries of your trace data and create custom data dashboards.
* [See data across accounts:](/docs/apm/distributed-tracing/ui-data/additional-distributed-tracing-features-new-relic-one) See a global view of traces from across all your accounts and applications.
* [Query traces programmatically:](/docs/apis/graphql-api/tutorials/query-distributed-trace-data-using-graphql-api) Query distributed trace data by using GraphQL in our NerdGraph API explorer.
